
/*
 This file was autogenerated via
 ----------------------------------------------------------------------------------------------------------------------------------------------------
 /Users/ahoenigmann/proj/go/bin/ldetool generate /Users/ahoenigmann/proj/go/src/github.com/ahoenigmann/parse/logparse.lde --go-string --package parse
 ----------------------------------------------------------------------------------------------------------------------------------------------------
 do not touch it with bare hands!
*/

package parse

import (
	"fmt"
	"strconv"
	"strings"
)

var spaceBslash = " \""

// Line ...
type Line struct {
	rest           string
	IP             string
	UserIdentifier string
	UserID         string
	Time           string
	Method         string
	Path           string
	Proto          string
	ResponseCode   int
	Size           int
}

// Extract ...
func (p *Line) Extract(line string) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp string
	var tmpInt int64

	// Take until ' ' as IP(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.IP = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as UserIdentifier(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.UserIdentifier = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as UserID(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.UserID = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '[' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '[' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until ']' as Time(string)
	pos = strings.IndexByte(p.rest, ']')
	if pos >= 0 {
		p.Time = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `" \""` and pass it
	if strings.HasPrefix(p.rest, spaceBslash) {
		p.rest = p.rest[len(spaceBslash):]
	} else {
		return false, nil
	}

	// Take until ' ' as Method(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.Method = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until ' ' as Path(string)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.Path = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '"' as Proto(string)
	pos = strings.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Proto = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.rest) >= 1 && p.rest[0] == ' ' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as ResponseCode(int)
	pos = strings.IndexByte(p.rest, ' ')
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(tmp, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.ResponseCode = int(tmpInt)

	// Take the rest as Size(int)
	if tmpInt, err = strconv.ParseInt(p.rest, 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(p.rest), err)
	}
	p.Size = int(tmpInt)
	p.rest = p.rest[len(p.rest):]
	return true, nil
}
